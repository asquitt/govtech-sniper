"""
RFP Sniper - Proposal Models
============================
Generated proposal responses with citation tracking.
"""

from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Optional

from pydantic import BaseModel
from sqlmodel import JSON, Column, Field, Relationship, SQLModel, Text

if TYPE_CHECKING:
    from app.models.knowledge_base import DocumentChunk, KnowledgeBaseDocument
    from app.models.rfp import RFP
    from app.models.user import User


class ProposalStatus(str, Enum):
    """Status of a proposal draft."""

    DRAFT = "draft"
    IN_PROGRESS = "in_progress"
    REVIEW = "review"
    FINAL = "final"
    SUBMITTED = "submitted"


class SectionStatus(str, Enum):
    """Status of individual proposal sections."""

    PENDING = "pending"
    GENERATING = "generating"
    GENERATED = "generated"
    EDITING = "editing"
    APPROVED = "approved"


class SubmissionPackageStatus(str, Enum):
    """Status of a submission package."""

    DRAFT = "draft"
    IN_REVIEW = "in_review"
    READY = "ready"
    SUBMITTED = "submitted"


# =============================================================================
# Citation Model (for tracking sources in generated text)
# =============================================================================


class Citation(BaseModel):
    """
    Citation reference in generated proposal text.

    The AI generates text with embedded citations like:
    "We have 5 years of Agile experience [[Source: Past_Perf_2022.pdf, Page 12]]"

    This model represents the parsed citation data.
    """

    source_file: str  # Original filename
    page_number: int | None = None
    section: str | None = None
    quote: str | None = None  # The specific quoted text
    confidence: float = 1.0  # AI confidence in this citation


class GeneratedContent(BaseModel):
    """
    AI-generated content with embedded citations.
    Stored in ProposalSection.
    """

    raw_text: str  # Text as generated by AI (with [[Source:...]] markers)
    clean_text: str  # Text with citations stripped for display
    citations: list[Citation]  # Parsed citation objects
    model_used: str  # Which Gemini model generated this
    tokens_used: int  # For usage tracking
    generation_time_seconds: float


# =============================================================================
# Proposal Model
# =============================================================================


class ProposalBase(SQLModel):
    """Base proposal fields."""

    title: str = Field(max_length=500)
    version: int = Field(default=1)
    status: ProposalStatus = Field(default=ProposalStatus.DRAFT)


class Proposal(ProposalBase, table=True):
    """
    The proposal document being generated for an RFP.
    Contains multiple sections, each addressing requirements.
    """

    __tablename__ = "proposals"

    id: int | None = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.id", index=True)
    rfp_id: int = Field(foreign_key="rfps.id", index=True)

    # Overall proposal metadata
    executive_summary: str | None = Field(default=None, sa_column=Column(Text))

    # Completion tracking
    total_sections: int = Field(default=0)
    completed_sections: int = Field(default=0)

    # Quality metrics
    compliance_score: float | None = None  # 0-100, based on requirements addressed

    # Export paths
    docx_export_path: str | None = Field(default=None, max_length=500)
    pdf_export_path: str | None = Field(default=None, max_length=500)

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    submitted_at: datetime | None = None

    # Relationships
    user: Optional["User"] = Relationship(back_populates="proposals")
    rfp: Optional["RFP"] = Relationship(back_populates="proposals")
    sections: list["ProposalSection"] = Relationship(back_populates="proposal")
    submission_packages: list["SubmissionPackage"] = Relationship(back_populates="proposal")

    def calculate_completion(self) -> float:
        """Calculate percentage of sections completed."""
        if self.total_sections == 0:
            return 0.0
        return (self.completed_sections / self.total_sections) * 100


# =============================================================================
# Proposal Section Model
# =============================================================================


class ProposalSectionBase(SQLModel):
    """Base section fields."""

    title: str = Field(max_length=255)
    section_number: str = Field(max_length=50)  # e.g., "3.1.2"
    requirement_id: str | None = None  # Links to ComplianceRequirement.id


class ProposalSection(ProposalSectionBase, table=True):
    """
    Individual section of a proposal addressing specific requirements.
    """

    __tablename__ = "proposal_sections"

    id: int | None = Field(default=None, primary_key=True)
    proposal_id: int = Field(foreign_key="proposals.id", index=True)

    # Content
    status: SectionStatus = Field(default=SectionStatus.PENDING)

    # The original requirement text being addressed
    requirement_text: str | None = Field(default=None, sa_column=Column(Text))

    # User-defined writing plan (bullet points, key themes, tone guidance)
    writing_plan: str | None = Field(default=None, sa_column=Column(Text))

    # AI-generated content (stored as JSON for GeneratedContent)
    generated_content: dict | None = Field(default=None, sa_column=Column(JSON))

    # User-edited final content
    final_content: str | None = Field(default=None, sa_column=Column(Text))

    # Word count tracking
    word_count: int | None = None

    # Quality scoring (populated by AIQualityScorer after generation)
    quality_score: float | None = None  # 0-100 overall quality score
    quality_breakdown: dict | None = Field(default=None, sa_column=Column(JSON))

    # Order for display
    display_order: int = Field(default=0)

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    generated_at: datetime | None = None

    # Relationship
    proposal: Proposal | None = Relationship(back_populates="sections")
    evidence_links: list["SectionEvidence"] = Relationship(back_populates="section")

    def get_generated_content(self) -> GeneratedContent | None:
        """Parse stored JSON into GeneratedContent object."""
        if self.generated_content:
            return GeneratedContent(**self.generated_content)
        return None

    def set_generated_content(self, content: GeneratedContent) -> None:
        """Store GeneratedContent as JSON."""
        self.generated_content = content.model_dump()
        self.status = SectionStatus.GENERATED
        self.generated_at = datetime.utcnow()
        self.word_count = len(content.clean_text.split())


# =============================================================================
# Proposal Version History Model
# =============================================================================


class ProposalVersionType(str, Enum):
    """Type of version change."""

    CREATED = "created"
    SECTION_GENERATED = "section_generated"
    SECTION_EDITED = "section_edited"
    STATUS_CHANGE = "status_change"
    EXPORTED = "exported"
    SUBMITTED = "submitted"
    RESTORED = "restored"


class ProposalVersion(SQLModel, table=True):
    """
    Version history for proposals.
    Tracks all changes to enable rollback and audit.
    """

    __tablename__ = "proposal_versions"

    id: int | None = Field(default=None, primary_key=True)
    proposal_id: int = Field(foreign_key="proposals.id", index=True)
    user_id: int = Field(foreign_key="users.id")

    # Version info
    version_number: int = Field(default=1)
    version_type: ProposalVersionType
    description: str = Field(max_length=500)

    # Snapshot of proposal state at this version
    snapshot: dict = Field(default={}, sa_column=Column(JSON))

    # Section-specific changes (if applicable)
    section_id: int | None = Field(default=None, foreign_key="proposal_sections.id")
    section_snapshot: dict | None = Field(default=None, sa_column=Column(JSON))

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)


class SectionVersion(SQLModel, table=True):
    """
    Version history for individual proposal sections.
    More granular tracking of content changes.
    """

    __tablename__ = "section_versions"

    id: int | None = Field(default=None, primary_key=True)
    section_id: int = Field(foreign_key="proposal_sections.id", index=True)
    user_id: int = Field(foreign_key="users.id")

    # Version info
    version_number: int

    # Content at this version
    content: str = Field(sa_column=Column(Text))
    word_count: int = Field(default=0)

    # Change details
    change_type: str = Field(max_length=50)  # "generated", "edited", "restored"
    change_summary: str | None = Field(default=None, max_length=500)

    # Diff from previous (optional, for efficient storage)
    diff_from_previous: str | None = Field(default=None, sa_column=Column(Text))

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)


# =============================================================================
# Submission Packages
# =============================================================================


class SubmissionPackage(SQLModel, table=True):
    """
    Submission package tracking for a proposal.

    Tracks export artifacts, due dates, and checklist completion.
    """

    __tablename__ = "submission_packages"

    id: int | None = Field(default=None, primary_key=True)
    proposal_id: int = Field(foreign_key="proposals.id", index=True)
    owner_id: int | None = Field(default=None, foreign_key="users.id")

    title: str = Field(max_length=255)
    status: SubmissionPackageStatus = Field(default=SubmissionPackageStatus.DRAFT)
    due_date: datetime | None = None
    submitted_at: datetime | None = None

    checklist: list[dict] = Field(default=[], sa_column=Column(JSON))
    notes: str | None = Field(default=None, sa_column=Column(Text))

    docx_export_path: str | None = Field(default=None, max_length=500)
    pdf_export_path: str | None = Field(default=None, max_length=500)

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    proposal: Proposal | None = Relationship(back_populates="submission_packages")


# =============================================================================
# Evidence Links (Proposal Sections <-> Knowledge Base)
# =============================================================================


class SectionEvidence(SQLModel, table=True):
    """
    Evidence links that connect proposal sections to knowledge base documents.
    """

    __tablename__ = "section_evidence"

    id: int | None = Field(default=None, primary_key=True)
    section_id: int = Field(foreign_key="proposal_sections.id", index=True)
    document_id: int = Field(foreign_key="knowledge_base_documents.id", index=True)
    chunk_id: int | None = Field(default=None, foreign_key="document_chunks.id")

    citation: str | None = Field(default=None, sa_column=Column(Text))
    notes: str | None = Field(default=None, sa_column=Column(Text))

    created_at: datetime = Field(default_factory=datetime.utcnow)

    section: ProposalSection | None = Relationship(back_populates="evidence_links")
    document: Optional["KnowledgeBaseDocument"] = Relationship(back_populates="evidence_links")
    chunk: Optional["DocumentChunk"] = Relationship(back_populates="evidence_links")
