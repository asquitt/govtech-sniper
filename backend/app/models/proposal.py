"""
RFP Sniper - Proposal Models
============================
Generated proposal responses with citation tracking.
"""

from datetime import datetime
from typing import TYPE_CHECKING, List, Optional
from enum import Enum

from sqlmodel import Field, Relationship, SQLModel, Column, JSON, Text
from pydantic import BaseModel

if TYPE_CHECKING:
    from app.models.user import User
    from app.models.rfp import RFP


class ProposalStatus(str, Enum):
    """Status of a proposal draft."""
    DRAFT = "draft"
    IN_PROGRESS = "in_progress"
    REVIEW = "review"
    FINAL = "final"
    SUBMITTED = "submitted"


class SectionStatus(str, Enum):
    """Status of individual proposal sections."""
    PENDING = "pending"
    GENERATING = "generating"
    GENERATED = "generated"
    EDITING = "editing"
    APPROVED = "approved"


# =============================================================================
# Citation Model (for tracking sources in generated text)
# =============================================================================

class Citation(BaseModel):
    """
    Citation reference in generated proposal text.
    
    The AI generates text with embedded citations like:
    "We have 5 years of Agile experience [[Source: Past_Perf_2022.pdf, Page 12]]"
    
    This model represents the parsed citation data.
    """
    source_file: str           # Original filename
    page_number: Optional[int] = None
    section: Optional[str] = None
    quote: Optional[str] = None  # The specific quoted text
    confidence: float = 1.0      # AI confidence in this citation


class GeneratedContent(BaseModel):
    """
    AI-generated content with embedded citations.
    Stored in ProposalSection.
    """
    raw_text: str              # Text as generated by AI (with [[Source:...]] markers)
    clean_text: str            # Text with citations stripped for display
    citations: List[Citation]  # Parsed citation objects
    model_used: str            # Which Gemini model generated this
    tokens_used: int           # For usage tracking
    generation_time_seconds: float


# =============================================================================
# Proposal Model
# =============================================================================

class ProposalBase(SQLModel):
    """Base proposal fields."""
    title: str = Field(max_length=500)
    version: int = Field(default=1)
    status: ProposalStatus = Field(default=ProposalStatus.DRAFT)


class Proposal(ProposalBase, table=True):
    """
    The proposal document being generated for an RFP.
    Contains multiple sections, each addressing requirements.
    """
    __tablename__ = "proposals"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.id", index=True)
    rfp_id: int = Field(foreign_key="rfps.id", index=True)
    
    # Overall proposal metadata
    executive_summary: Optional[str] = Field(default=None, sa_column=Column(Text))
    
    # Completion tracking
    total_sections: int = Field(default=0)
    completed_sections: int = Field(default=0)
    
    # Quality metrics
    compliance_score: Optional[float] = None  # 0-100, based on requirements addressed
    
    # Export paths
    docx_export_path: Optional[str] = Field(default=None, max_length=500)
    pdf_export_path: Optional[str] = Field(default=None, max_length=500)
    
    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    submitted_at: Optional[datetime] = None
    
    # Relationships
    user: Optional["User"] = Relationship(back_populates="proposals")
    rfp: Optional["RFP"] = Relationship(back_populates="proposals")
    sections: List["ProposalSection"] = Relationship(back_populates="proposal")

    def calculate_completion(self) -> float:
        """Calculate percentage of sections completed."""
        if self.total_sections == 0:
            return 0.0
        return (self.completed_sections / self.total_sections) * 100


# =============================================================================
# Proposal Section Model
# =============================================================================

class ProposalSectionBase(SQLModel):
    """Base section fields."""
    title: str = Field(max_length=255)
    section_number: str = Field(max_length=50)  # e.g., "3.1.2"
    requirement_id: Optional[str] = None  # Links to ComplianceRequirement.id


class ProposalSection(ProposalSectionBase, table=True):
    """
    Individual section of a proposal addressing specific requirements.
    """
    __tablename__ = "proposal_sections"

    id: Optional[int] = Field(default=None, primary_key=True)
    proposal_id: int = Field(foreign_key="proposals.id", index=True)
    
    # Content
    status: SectionStatus = Field(default=SectionStatus.PENDING)
    
    # The original requirement text being addressed
    requirement_text: Optional[str] = Field(default=None, sa_column=Column(Text))
    
    # AI-generated content (stored as JSON for GeneratedContent)
    generated_content: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    
    # User-edited final content
    final_content: Optional[str] = Field(default=None, sa_column=Column(Text))
    
    # Word count tracking
    word_count: Optional[int] = None
    
    # Order for display
    display_order: int = Field(default=0)
    
    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    generated_at: Optional[datetime] = None
    
    # Relationship
    proposal: Optional[Proposal] = Relationship(back_populates="sections")

    def get_generated_content(self) -> Optional[GeneratedContent]:
        """Parse stored JSON into GeneratedContent object."""
        if self.generated_content:
            return GeneratedContent(**self.generated_content)
        return None
    
    def set_generated_content(self, content: GeneratedContent) -> None:
        """Store GeneratedContent as JSON."""
        self.generated_content = content.model_dump()
        self.status = SectionStatus.GENERATED
        self.generated_at = datetime.utcnow()
        self.word_count = len(content.clean_text.split())


# =============================================================================
# Proposal Version History Model
# =============================================================================

class ProposalVersionType(str, Enum):
    """Type of version change."""
    CREATED = "created"
    SECTION_GENERATED = "section_generated"
    SECTION_EDITED = "section_edited"
    STATUS_CHANGE = "status_change"
    EXPORTED = "exported"
    SUBMITTED = "submitted"
    RESTORED = "restored"


class ProposalVersion(SQLModel, table=True):
    """
    Version history for proposals.
    Tracks all changes to enable rollback and audit.
    """
    __tablename__ = "proposal_versions"

    id: Optional[int] = Field(default=None, primary_key=True)
    proposal_id: int = Field(foreign_key="proposals.id", index=True)
    user_id: int = Field(foreign_key="users.id")

    # Version info
    version_number: int = Field(default=1)
    version_type: ProposalVersionType
    description: str = Field(max_length=500)

    # Snapshot of proposal state at this version
    snapshot: dict = Field(default={}, sa_column=Column(JSON))

    # Section-specific changes (if applicable)
    section_id: Optional[int] = Field(default=None, foreign_key="proposal_sections.id")
    section_snapshot: Optional[dict] = Field(default=None, sa_column=Column(JSON))

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)


class SectionVersion(SQLModel, table=True):
    """
    Version history for individual proposal sections.
    More granular tracking of content changes.
    """
    __tablename__ = "section_versions"

    id: Optional[int] = Field(default=None, primary_key=True)
    section_id: int = Field(foreign_key="proposal_sections.id", index=True)
    user_id: int = Field(foreign_key="users.id")

    # Version info
    version_number: int

    # Content at this version
    content: str = Field(sa_column=Column(Text))
    word_count: int = Field(default=0)

    # Change details
    change_type: str = Field(max_length=50)  # "generated", "edited", "restored"
    change_summary: Optional[str] = Field(default=None, max_length=500)

    # Diff from previous (optional, for efficient storage)
    diff_from_previous: Optional[str] = Field(default=None, sa_column=Column(Text))

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)

